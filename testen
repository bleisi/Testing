-- VIP UNIFIED FINAL (Single GUI + Draggable)
-- Put this LocalScript in StarterPlayerScripts
-- Change requested: Challenge Check starts ON.

-- ===== SINGLETON GUARD =====
do
	_G.__VIP_MULTI_AUTO_RUNNING = _G.__VIP_MULTI_AUTO_RUNNING or { running = false, token = 0 }
	if _G.__VIP_MULTI_AUTO_RUNNING.running then
		warn("[VIP] Already running, blocked duplicate.")
		return
	end
	_G.__VIP_MULTI_AUTO_RUNNING.running = true
	_G.__VIP_MULTI_AUTO_RUNNING.token += 1
end

local RUN_TOKEN = _G.__VIP_MULTI_AUTO_RUNNING.token
local function stillCurrent()
	return _G.__VIP_MULTI_AUTO_RUNNING
		and _G.__VIP_MULTI_AUTO_RUNNING.running == true
		and _G.__VIP_MULTI_AUTO_RUNNING.token == RUN_TOKEN
end

-- ===== SERVICES =====
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")
local Stats = game:GetService("Stats")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- remove old gui from previous runs
pcall(function()
	for _, n in ipairs({ "VIP_MultiAutoGui", "VIPPanelGui", "VIPUnifiedGui" }) do
		local old = playerGui:FindFirstChild(n)
		if old then old:Destroy() end
	end
end)

-- ===== REMOTES =====
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local MoneyRemote = Remotes:WaitForChild("Money")
local ChampionRemote = Remotes:WaitForChild("Champion")
local UpboardRemote = Remotes:WaitForChild("Upboard")
local TilePlacementRemote = Remotes:WaitForChild("TilePlacement")

-- ===== CONFIG (MultiAuto) =====
local thresholds = { 975, 1150, 1725, 2010, 2530, 2750 }

local PRESET_ATTRIBUTE_KEY = "Champion"
local PRESET_ATTRIBUTE_VALUE = "Blade Master"

local UPBOARD_COOLDOWN = 0.75
local UPBOARD_LOOP_INTERVAL = 0.9
local ENDGAME_DELAY = 10 -- wait before PlayAgain/Leave

-- After 15 minutes from script start, ALWAYS leave/return lobby on endgame
local FORCE_LEAVE_AFTER_SECONDS = 15 * 60

-- WaveSkip -> Place -> Vote
local PLACE_ACTION = "Place"
local PLACE_SLOT = "Slot_04"
local PLACE_NAME = "Blade Master"
local PLACE_CFRAME = CFrame.new(
	3838.8388671875, 256.97607421875, -3677.232177734375,
	0, 0, 1,
	0, 1, 0,
	-1, 0, 0
)
local PLACE_TILE_NAME = "PlacementTile_1_3"
local PLACE_ZERO = 0
local AFTER_PLACE_WAIT = 0.35
local MAX_PLACE_TRIES_THIS_WAVESKIP = 3

-- Auto-Rejoin (Anti-crash)
local autoRejoinEnabled = true
local REJOIN_AT_MB = 3500
local REJOIN_CONFIRM_SECONDS = 8
local REJOIN_COOLDOWN_SECONDS = 120

-- ===== CONFIG (Challenge) =====
local CHECK_INTERVAL = 0.25
local TELEPORT_OFFSET_Y = 5

-- TP priority (highest -> lowest)
local TARGET_PRIORITY = {
	"C_A_A_Power Fragment",
	"C_A_A_Deluxe Dice",
	"C_A_C_Dice",
	"C_C_C_Gratifying Soul",
}

local RETRIGGER_DISTANCE = 35
local TELEPORT_COOLDOWN = 2.0

local PRESS_START_DISTANCE = 25
local START_PRESS_COOLDOWN = 0.35

local NPC_FOLDER_PATH = { "NPCs", "Sung6S" }
local R6_LEG = "Left Leg"
local R15_LEG_CANDIDATES = { "LeftLowerLeg", "LeftUpperLeg" }

local HOURLY_IDS = { "Hourly_01_01", "Hourly_02_01", "Hourly_03_01" }

local LOBBY_FOLDER_NAME = "Lobby Relatives"
local DOORS_REMOTE_NAME = "Doors"
local START_A, START_B = "Play", "Challenge"
local LEAVE_A, LEAVE_B = "Leave", "Challenge"

-- ===== HELPERS =====
local function norm(v)
	return tostring(v or ""):lower():gsub("%s+", "")
end
local wantValNorm = norm(PRESET_ATTRIBUTE_VALUE)

local function safeFindChild(root, name)
	if not root then return nil end
	return root:FindFirstChild(name)
end

local function setTextIfChanged(label, txt)
	if label and label.Text ~= txt then
		label.Text = txt
	end
end

local function getClientMemoryMB()
	return Stats:GetTotalMemoryUsageMb()
end

local function getChar()
	return player.Character or player.CharacterAdded:Wait()
end

local function getHRP()
	local char = getChar()
	return char:FindFirstChild("HumanoidRootPart")
end

local function teleportToPart(part)
	local hrp = getHRP()
	if hrp and part and part:IsA("BasePart") then
		hrp.CFrame = part.CFrame * CFrame.new(0, TELEPORT_OFFSET_Y, 0)
	end
end

local function findAncestorByName(inst, name)
	local cur = inst
	while cur do
		if cur.Name == name then return cur end
		cur = cur.Parent
	end
	return nil
end

local function distanceFromPlayerTo(part)
	local hrp = getHRP()
	if not hrp or not part then return math.huge end
	return (hrp.Position - part.Position).Magnitude
end

local function getSungLeftLegPart()
	local cur = workspace
	for _, name in ipairs(NPC_FOLDER_PATH) do
		cur = cur:FindFirstChild(name)
		if not cur then return nil end
	end

	local leg = cur:FindFirstChild(R6_LEG)
	if leg and leg:IsA("BasePart") then
		return leg
	end

	for _, cand in ipairs(R15_LEG_CANDIDATES) do
		local p = cur:FindFirstChild(cand)
		if p and p:IsA("BasePart") then
			return p
		end
	end
	return nil
end

-- Lazy Arena tile fetch (NO infinite yield)
local function getPlaceTile()
	local arena = Workspace:FindFirstChild("Arena")
	if not arena then return nil end
	return arena:FindFirstChild(PLACE_TILE_NAME)
end

-- ===== MAID =====
local Maid = {}
Maid.__index = Maid
function Maid.new()
	return setmetatable({ tasks = {} }, Maid)
end
function Maid:Give(t)
	table.insert(self.tasks, t)
	return t
end
function Maid:DoCleaning()
	for i = #self.tasks, 1, -1 do
		local t = self.tasks[i]
		self.tasks[i] = nil
		if typeof(t) == "RBXScriptConnection" then
			pcall(function() t:Disconnect() end)
		elseif typeof(t) == "Instance" then
			pcall(function() t:Destroy() end)
		elseif type(t) == "function" then
			pcall(t)
		end
	end
end

local maid = Maid.new()

local function stopAll()
	if not stillCurrent() then return end
	_G.__VIP_MULTI_AUTO_RUNNING.running = false
	maid:DoCleaning()
end

-- ===== 15 MINUTE FORCE-LEAVE TIMER =====
local scriptStartAt = os.clock()
local forceLeaveToLobby = false

task.spawn(function()
	while stillCurrent() do
		if (not forceLeaveToLobby) and (os.clock() - scriptStartAt) >= FORCE_LEAVE_AFTER_SECONDS then
			forceLeaveToLobby = true
		end
		task.wait(1)
	end
end)

-- ===== PRESET CACHE (Blade Master) =====
local presetsFolder = Workspace:WaitForChild("Presets")
local cachedBladePreset = nil

local function isBladeMasterPreset(preset)
	local attr = preset:GetAttribute(PRESET_ATTRIBUTE_KEY)
	return attr ~= nil and norm(attr) == wantValNorm
end

local function rebuildBladeCache()
	cachedBladePreset = nil
	for _, child in ipairs(presetsFolder:GetChildren()) do
		if isBladeMasterPreset(child) then
			cachedBladePreset = child
			return
		end
	end
end

rebuildBladeCache()

maid:Give(presetsFolder.ChildAdded:Connect(function(child)
	if not stillCurrent() then return end
	if not cachedBladePreset and isBladeMasterPreset(child) then
		cachedBladePreset = child
	end
end))

maid:Give(presetsFolder.ChildRemoved:Connect(function(child)
	if not stillCurrent() then return end
	if child == cachedBladePreset then
		rebuildBladeCache()
	end
end))

local function getBladePreset()
	if cachedBladePreset and cachedBladePreset.Parent == presetsFolder then
		return cachedBladePreset
	end
	rebuildBladeCache()
	return cachedBladePreset
end

-- ===== FEATURE 1: AUTO UPGRADE =====
local autoUpgradeEnabled = true -- default ON
local currentMoney = 0
local nextIndex = 1
local upgradeBusy = false

local function resetUpgrades(statusFn)
	nextIndex = 1
	upgradeBusy = false
	if statusFn then statusFn("Upgrade: Reset") end
end

local function fireUpgradePreset()
	local preset = getBladePreset()
	if not preset then
		return false, "Upgrade: Preset not found"
	end
	ChampionRemote:FireServer("Upgrade", preset)
	return true, "Upgrade: Sent Upgrade"
end

local function processUpgrades(updateUIFn)
	if not autoUpgradeEnabled then return end
	if upgradeBusy then return end
	if nextIndex > #thresholds then return end

	upgradeBusy = true
	while autoUpgradeEnabled
		and nextIndex <= #thresholds
		and (currentMoney + 1e-6) >= thresholds[nextIndex]
	do
		local target = thresholds[nextIndex]
		if updateUIFn then updateUIFn(("Upgrade: Upgrading @ %d..."):format(target)) end

		local ok, msg = fireUpgradePreset()
		if not ok then
			if updateUIFn then updateUIFn(msg) end
			break
		end

		nextIndex += 1
		task.wait(0.25)
	end
	upgradeBusy = false
end

-- ===== FEATURE 2: AUTO UPBOARD (PlayAgain/Leave) =====
local autoUpboardEnabled = true -- default ON
local upboardLastAction = nil
local upboardLastFireAt = 0

local function tryGetPlayAgainHolder()
	local upboard = playerGui:FindFirstChild("Upboard")
	if not upboard then return nil end
	local result = safeFindChild(upboard, "Result")
	local main = safeFindChild(result, "Main")
	local options = safeFindChild(main, "Options")
	return safeFindChild(options, "PlayAgainButtonHolder")
end

local function desiredUpboardAction(holder)
	if forceLeaveToLobby then
		return "Leave"
	end
	if not holder then return nil end
	return holder.Visible and "PlayAgain" or "Leave"
end

local function fireUpboardAction(action, updateUIFn, force)
	if not action then return end

	local now = os.clock()
	if not force then
		if now - upboardLastFireAt < UPBOARD_COOLDOWN then return end
		if action == upboardLastAction then return end
	end

	upboardLastAction = action
	upboardLastFireAt = now
	UpboardRemote:FireServer(action)
	if updateUIFn then updateUIFn(("Upboard: Sent %s"):format(action)) end
end

local function startUpboardLoop(updateUIFn, setPlayAgainVisibleLabelFn)
	task.spawn(function()
		while stillCurrent() do
			if autoUpboardEnabled then
				local holder = tryGetPlayAgainHolder()
				if setPlayAgainVisibleLabelFn then
					setPlayAgainVisibleLabelFn(holder and holder.Visible or nil)
				end
				local action = desiredUpboardAction(holder)
				fireUpboardAction(action, updateUIFn, false)
			end
			task.wait(UPBOARD_LOOP_INTERVAL)
		end
	end)
end

-- ===== EndGame handling =====
local endGameTaskId = 0
local function handleEndGame(updateUIFn, setPlayAgainVisibleLabelFn)
	endGameTaskId += 1
	local myId = endGameTaskId

	resetUpgrades(updateUIFn)
	if updateUIFn then updateUIFn("Upgrade: Reset (EndGame)") end
	if updateUIFn then updateUIFn() end
	processUpgrades(updateUIFn)

	task.delay(ENDGAME_DELAY, function()
		if not stillCurrent() then return end
		if myId ~= endGameTaskId then return end

		local holder = tryGetPlayAgainHolder()
		if setPlayAgainVisibleLabelFn then
			setPlayAgainVisibleLabelFn(holder and holder.Visible or nil)
		end

		local tries = 0
		while stillCurrent() and (not holder) and tries < 20 do
			task.wait(0.25)
			holder = tryGetPlayAgainHolder()
			tries += 1
			if setPlayAgainVisibleLabelFn then
				setPlayAgainVisibleLabelFn(holder and holder.Visible or nil)
			end
		end

		local action
		if forceLeaveToLobby then
			action = "Leave"
		else
			action = (holder and holder.Visible) and "PlayAgain" or "Leave"
		end

		upboardLastAction = nil
		upboardLastFireAt = 0
		fireUpboardAction(action, updateUIFn, true)
	end)
end

local function handleTurnOffBoard(updateUIFn)
	resetUpgrades(updateUIFn)
end

-- ===== FEATURE 3: WAVESKIP -> PLACE -> VOTE =====
local autoWaveSkipEnabled = true -- default ON
local handlingWaveSkip = false
local waveConn = nil
local waveHookToken = 0

local function tryGetWaveSkipGui()
	local upboard = playerGui:FindFirstChild("Upboard")
	if not upboard then return nil end
	return upboard:FindFirstChild("WaveSkip")
end

local function placeBladeMaster(updateUIFn)
	local tile = getPlaceTile()
	if not tile then
		if updateUIFn then updateUIFn("WaveSkip: Arena not loaded yet (waiting...)") end
		return false
	end

	TilePlacementRemote:FireServer(
		PLACE_ACTION, PLACE_SLOT, PLACE_NAME, PLACE_CFRAME, tile, PLACE_ZERO
	)
	return true
end

local function handleWaveSkipVisible(updateUIFn)
	if handlingWaveSkip then return end
	handlingWaveSkip = true

	if updateUIFn then updateUIFn("WaveSkip: Visible -> checking Blade Master...") end

	local preset = getBladePreset()
	if preset then
		if updateUIFn then updateUIFn(("WaveSkip: Found (%s) -> Vote"):format(preset.Name)) end
		UpboardRemote:FireServer("Vote")
		handlingWaveSkip = false
		return
	end

	if updateUIFn then updateUIFn("WaveSkip: Not found -> placing Slot_04...") end

	for attempt = 1, MAX_PLACE_TRIES_THIS_WAVESKIP do
		placeBladeMaster(updateUIFn)
		if updateUIFn then updateUIFn(("WaveSkip: Placed %d/%d -> wait"):format(attempt, MAX_PLACE_TRIES_THIS_WAVESKIP)) end
		task.wait(AFTER_PLACE_WAIT)

		preset = getBladePreset()
		if preset then
			if updateUIFn then updateUIFn(("WaveSkip: Now found (%s) -> Vote"):format(preset.Name)) end
			UpboardRemote:FireServer("Vote")
			handlingWaveSkip = false
			return
		end
	end

	if updateUIFn then updateUIFn("WaveSkip: Still not found -> Vote anyway") end
	UpboardRemote:FireServer("Vote")
	handlingWaveSkip = false
end

local function unhookWaveSkip()
	if waveConn then
		waveConn:Disconnect()
		waveConn = nil
	end
end

local function hookWaveSkip(updateUIFn, setWaveSkipVisibleLabelFn)
	waveHookToken += 1
	local myToken = waveHookToken

	task.spawn(function()
		while stillCurrent() and myToken == waveHookToken do
			local waveSkip = tryGetWaveSkipGui()
			if waveSkip then
				unhookWaveSkip()

				if setWaveSkipVisibleLabelFn then
					setWaveSkipVisibleLabelFn(waveSkip.Visible)
				end

				local last = waveSkip.Visible

				waveConn = waveSkip:GetPropertyChangedSignal("Visible"):Connect(function()
					if not stillCurrent() then return end
					if myToken ~= waveHookToken then return end

					if setWaveSkipVisibleLabelFn then
						setWaveSkipVisibleLabelFn(waveSkip.Visible)
					end

					if autoWaveSkipEnabled and (not last) and waveSkip.Visible then
						handleWaveSkipVisible(updateUIFn)
					end
					last = waveSkip.Visible
				end)

				maid:Give(waveConn)

				if autoWaveSkipEnabled and waveSkip.Visible then
					handleWaveSkipVisible(updateUIFn)
				end

				while stillCurrent() and myToken == waveHookToken and waveSkip.Parent do
					task.wait(0.6)
				end
			else
				if setWaveSkipVisibleLabelFn then
					setWaveSkipVisibleLabelFn(nil)
				end
				task.wait(0.6)
			end
		end
	end)
end

-- ===== CHALLENGE SCAN HELPERS =====
local function tryGetHolderForHourly(hourlyId)
	local doors = workspace:FindFirstChild("Doors")
	if not doors then return nil end

	local challenge = doors:FindFirstChild("Challenge")
	if not challenge then return nil end

	local hourly = challenge:FindFirstChild(hourlyId)
	if not hourly then return nil end

	local matchDisplayPart = hourly:FindFirstChild("MatchDisplayPart")
	if not matchDisplayPart then return nil end

	local surfaceGui = matchDisplayPart:FindFirstChild("SurfaceGui")
	if not surfaceGui then return nil end

	local guiFrame = surfaceGui:FindFirstChild("MatchDisplayFrame")
	if not guiFrame then return nil end

	local rewards = guiFrame:FindFirstChild("ChallengeRewards")
	if not rewards then return nil end

	return rewards:FindFirstChild("Holder")
end

local function findBestMatchDisplayPart()
	for _, targetName in ipairs(TARGET_PRIORITY) do
		for _, hourlyId in ipairs(HOURLY_IDS) do
			local holder = tryGetHolderForHourly(hourlyId)
			if holder then
				local found = holder:FindFirstChild(targetName, true)
				if found then
					local matchDisplayPart = findAncestorByName(holder, "MatchDisplayPart")
					if matchDisplayPart and matchDisplayPart:IsA("BasePart") then
						return matchDisplayPart, targetName
					end
				end
			end
		end
	end
	return nil
end

-- ===== DOORS REMOTE (Lobby Relatives -> Doors) =====
local function getDoorsRemote()
	local lobby = ReplicatedStorage:FindFirstChild(LOBBY_FOLDER_NAME)
	local r = lobby and lobby:FindFirstChild(DOORS_REMOTE_NAME) or nil
	if r and r:IsA("RemoteEvent") then return r end
	return nil
end

local function requestChallengeStart()
	local doors = getDoorsRemote()
	if not doors then return false end
	doors:FireServer(START_A, START_B)
	return true
end

local function requestChallengeLeave()
	local doors = getDoorsRemote()
	if not doors then return false end
	doors:FireServer(LEAVE_A, LEAVE_B)
	return true
end

-- =======================
-- SINGLE GUI (Draggable)
-- =======================
local gui = Instance.new("ScreenGui")
gui.Name = "VIPUnifiedGui"
gui.ResetOnSpawn = false
gui.Parent = playerGui
maid:Give(gui)

local main = Instance.new("Frame")
main.Size = UDim2.new(0, 640, 0, 365)
main.Position = UDim2.new(0, 20, 0.5, -182)
main.BackgroundColor3 = Color3.fromRGB(25, 25, 28)
main.BorderSizePixel = 0
main.Parent = gui
maid:Give(main)

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 12)
mainCorner.Parent = main
maid:Give(mainCorner)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -60, 0, 24)
title.Position = UDim2.new(0, 10, 0, 8)
title.BackgroundTransparency = 1
title.Text = "VIP Auto Panel"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = main
maid:Give(title)

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 28, 0, 24)
closeBtn.Position = UDim2.new(1, -38, 0, 8)
closeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
closeBtn.BorderSizePixel = 0
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 14
closeBtn.Parent = main
maid:Give(closeBtn)

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 8)
closeCorner.Parent = closeBtn
maid:Give(closeCorner)

local function makeLabel(y, txt, size)
	local l = Instance.new("TextLabel")
	l.Size = UDim2.new(0, 330, 0, 18)
	l.Position = UDim2.new(0, 10, 0, y)
	l.BackgroundTransparency = 1
	l.Text = txt
	l.TextColor3 = Color3.fromRGB(200, 200, 200)
	l.Font = Enum.Font.Gotham
	l.TextSize = size or 13
	l.TextXAlignment = Enum.TextXAlignment.Left
	l.Parent = main
	maid:Give(l)
	return l
end

local upgradeStatus = makeLabel(38, "Upgrade: ON", 13)
local moneyLabel = makeLabel(58, "Money: 0", 13); moneyLabel.TextColor3 = Color3.fromRGB(160,160,160)
local nextLabel = makeLabel(78, "Next: 975", 13); nextLabel.TextColor3 = Color3.fromRGB(160,160,160)
local presetLabel = makeLabel(98, "Preset: (searching...)", 12); presetLabel.TextColor3 = Color3.fromRGB(160,160,160)

local upboardStatus = makeLabel(128, "Upboard: ON", 13)
local playAgainVisibleLabel = makeLabel(148, "PlayAgainHolder.Visible: (waiting...)", 12); playAgainVisibleLabel.TextColor3 = Color3.fromRGB(160,160,160)

local waveSkipStatus = makeLabel(178, "WaveSkip: ON", 13)
local waveSkipVisibleLabel = makeLabel(198, "WaveSkip.Visible: (waiting...)", 12); waveSkipVisibleLabel.TextColor3 = Color3.fromRGB(160,160,160)

local memoryLabel = makeLabel(228, "Memory: ...", 12); memoryLabel.TextColor3 = Color3.fromRGB(160,160,160)

local challengeTitle = Instance.new("TextLabel")
challengeTitle.Size = UDim2.new(0, 280, 0, 22)
challengeTitle.Position = UDim2.new(0, 350, 0, 34)
challengeTitle.BackgroundTransparency = 1
challengeTitle.Text = "VIP Challenge"
challengeTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
challengeTitle.Font = Enum.Font.GothamBold
challengeTitle.TextSize = 16
challengeTitle.TextXAlignment = Enum.TextXAlignment.Left
challengeTitle.Parent = main
maid:Give(challengeTitle)

local panelStatus = Instance.new("TextLabel")
panelStatus.Size = UDim2.new(0, 280, 0, 18)
panelStatus.Position = UDim2.new(0, 350, 0, 58)
panelStatus.BackgroundTransparency = 1
panelStatus.Text = "Status: Booting..."
panelStatus.TextColor3 = Color3.fromRGB(200, 200, 200)
panelStatus.Font = Enum.Font.Gotham
panelStatus.TextSize = 13
panelStatus.TextXAlignment = Enum.TextXAlignment.Left
panelStatus.Parent = main
maid:Give(panelStatus)

local function makeBtn(x, y, w, h, text, bg, tc)
	local b = Instance.new("TextButton")
	b.Size = UDim2.new(0, w, 0, h)
	b.Position = UDim2.new(0, x, 0, y)
	b.BackgroundColor3 = bg
	b.BorderSizePixel = 0
	b.Text = text
	b.TextColor3 = tc
	b.Font = Enum.Font.GothamBold
	b.TextSize = 16
	b.Parent = main
	maid:Give(b)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, 10)
	c.Parent = b
	maid:Give(c)
	return b
end

local tpNpcBtn = makeBtn(350, 82, 280, 44, "TP to Sung6S Left Leg", Color3.fromRGB(50,150,250), Color3.fromRGB(255,255,255))
local challengeBtn = makeBtn(350, 134, 280, 44, "Challenge Check: ON", Color3.fromRGB(70,140,70), Color3.fromRGB(255,255,255))
local startBtn = makeBtn(350, 188, 280, 40, "START", Color3.fromRGB(240,170,60), Color3.fromRGB(0,0,0))
local leaveBtn = makeBtn(350, 234, 280, 40, "LEAVE", Color3.fromRGB(220,70,70), Color3.fromRGB(255,255,255))
local autoStartBtn = makeBtn(350, 280, 280, 40, "Auto-Start: ON", Color3.fromRGB(70,140,70), Color3.fromRGB(255,255,255))

local function makeSmallToggle(x, text)
	local b = Instance.new("TextButton")
	b.Size = UDim2.new(0, 200, 0, 34)
	b.Position = UDim2.new(0, x, 1, -44)
	b.BackgroundColor3 = Color3.fromRGB(0, 170, 85)
	b.BorderSizePixel = 0
	b.Text = text
	b.TextColor3 = Color3.fromRGB(255, 255, 255)
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.Parent = main
	maid:Give(b)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, 10)
	c.Parent = b
	maid:Give(c)
	return b
end

local upgradeToggle = makeSmallToggle(10, "Upgrade: ON")
local upboardToggle = makeSmallToggle(220, "Upboard: ON")
local waveSkipToggle = makeSmallToggle(430, "WaveSkip: ON")

local rejoinToggle = Instance.new("TextButton")
rejoinToggle.Size = UDim2.new(0, 330, 0, 30)
rejoinToggle.Position = UDim2.new(0, 10, 0, 252)
rejoinToggle.BackgroundColor3 = Color3.fromRGB(0, 170, 85)
rejoinToggle.BorderSizePixel = 0
rejoinToggle.Text = "Auto-Rejoin: ON"
rejoinToggle.TextColor3 = Color3.fromRGB(255,255,255)
rejoinToggle.Font = Enum.Font.GothamBold
rejoinToggle.TextSize = 13
rejoinToggle.Parent = main
maid:Give(rejoinToggle)
local rC = Instance.new("UICorner"); rC.CornerRadius = UDim.new(0, 10); rC.Parent = rejoinToggle; maid:Give(rC)

-- ===== DRAGGING =====
do
	local dragging, dragInput, dragStart, startPos = false, nil, nil, nil
	local function updateDrag(input)
		local delta = input.Position - dragStart
		main.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end

	maid:Give(main.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = main.Position
			local conn
			conn = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					if conn then conn:Disconnect() end
				end
			end)
		end
	end))

	maid:Give(main.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end))

	maid:Give(UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			updateDrag(input)
		end
	end))
end

-- ===== UI functions =====
local function setPlayAgainVisibleLabel(v)
	if v == nil then
		setTextIfChanged(playAgainVisibleLabel, "PlayAgainHolder.Visible: (waiting...)")
	else
		setTextIfChanged(playAgainVisibleLabel, "PlayAgainHolder.Visible: " .. tostring(v))
	end
end

local function setWaveSkipVisibleLabel(v)
	if v == nil then
		setTextIfChanged(waveSkipVisibleLabel, "WaveSkip.Visible: (waiting...)")
	else
		setTextIfChanged(waveSkipVisibleLabel, "WaveSkip.Visible: " .. tostring(v))
	end
end

local function updateTogglesUI()
	upgradeToggle.Text = autoUpgradeEnabled and "Upgrade: ON" or "Upgrade: OFF"
	upgradeToggle.BackgroundColor3 = autoUpgradeEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)
	upgradeStatus.Text = autoUpgradeEnabled and "Upgrade: ON" or "Upgrade: OFF"

	upboardToggle.Text = autoUpboardEnabled and "Upboard: ON" or "Upboard: OFF"
	upboardToggle.BackgroundColor3 = autoUpboardEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)
	upboardStatus.Text = autoUpboardEnabled and "Upboard: ON" or "Upboard: OFF"

	waveSkipToggle.Text = autoWaveSkipEnabled and "WaveSkip: ON" or "WaveSkip: OFF"
	waveSkipToggle.BackgroundColor3 = autoWaveSkipEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)
	waveSkipStatus.Text = autoWaveSkipEnabled and "WaveSkip: ON" or "WaveSkip: OFF"

	rejoinToggle.Text = autoRejoinEnabled and "Auto-Rejoin: ON" or "Auto-Rejoin: OFF"
	rejoinToggle.BackgroundColor3 = autoRejoinEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)
end

local function updateUI(statusText)
	setTextIfChanged(moneyLabel, ("Money: %d"):format(math.floor(currentMoney + 0.5)))
	local nextTarget = thresholds[nextIndex]
	setTextIfChanged(nextLabel, nextTarget and ("Next: %d"):format(nextTarget) or "Next: DONE")

	local preset = getBladePreset()
	setTextIfChanged(presetLabel, ("Preset: %s"):format(preset and preset.Name or "(not found)"))

	updateTogglesUI()

	if statusText then
		if statusText:sub(1, 7) == "Upgrade" then
			setTextIfChanged(upgradeStatus, statusText)
		elseif statusText:sub(1, 6) == "Upboard" then
			setTextIfChanged(upboardStatus, statusText)
		elseif statusText:sub(1, 7) == "WaveSkip" then
			setTextIfChanged(waveSkipStatus, statusText)
		end
	end
end

-- ===== Challenge state (START ON) =====
local challengeEnabled = true -- <- changed
local autoStartEnabled = true
local lastTargetPart = nil
local lastTeleportTime = 0
local lastStartPressTime = 0
local tpToSungOnEnableDone = false

local function updateChallengeText()
	if challengeEnabled then
		challengeBtn.Text = "Challenge Check: ON"
		challengeBtn.BackgroundColor3 = Color3.fromRGB(70, 140, 70)
	else
		challengeBtn.Text = "Challenge Check: OFF"
		challengeBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	end
end

local function updateAutoStartText()
	if autoStartEnabled then
		autoStartBtn.Text = "Auto-Start: ON"
		autoStartBtn.BackgroundColor3 = Color3.fromRGB(70, 140, 70)
	else
		autoStartBtn.Text = "Auto-Start: OFF"
		autoStartBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	end
end

updateChallengeText()
updateAutoStartText()
updateUI()

-- ===== AUTO-REJOIN LOOP =====
local lastOverAt = 0
local lastRejoinAt = 0

task.spawn(function()
	while stillCurrent() do
		local mem = getClientMemoryMB()
		setTextIfChanged(memoryLabel, ("Memory: %d MB"):format(math.floor(mem + 0.5)))

		local now = os.clock()

		if autoRejoinEnabled then
			if mem >= REJOIN_AT_MB then
				if lastOverAt == 0 then lastOverAt = now end

				local overFor = now - lastOverAt
				local sinceLast = now - lastRejoinAt

				if overFor >= REJOIN_CONFIRM_SECONDS and sinceLast >= REJOIN_COOLDOWN_SECONDS then
					lastRejoinAt = now
					lastOverAt = 0

					pcall(function() stopAll() end)
					pcall(function()
						TeleportService:Teleport(game.PlaceId, player)
					end)
					return
				end
			else
				lastOverAt = 0
			end
		else
			lastOverAt = 0
		end

		task.wait(1)
	end
end)

-- ===== BUTTON EVENTS =====
maid:Give(closeBtn.MouseButton1Click:Connect(function() stopAll() end))

maid:Give(rejoinToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoRejoinEnabled = not autoRejoinEnabled
	updateUI()
end))

maid:Give(MoneyRemote.OnClientEvent:Connect(function(action, amount)
	if not stillCurrent() then return end
	if action ~= "Update" then return end
	currentMoney = tonumber(amount) or 0
	updateUI()
	processUpgrades(updateUI)
end))

maid:Give(upgradeToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoUpgradeEnabled = not autoUpgradeEnabled
	updateUI()
	processUpgrades(updateUI)
end))

maid:Give(upboardToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoUpboardEnabled = not autoUpboardEnabled
	if autoUpboardEnabled then
		upboardLastAction = nil
		upboardLastFireAt = 0
	end
	updateUI()
end))

maid:Give(waveSkipToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoWaveSkipEnabled = not autoWaveSkipEnabled
	handlingWaveSkip = false
	updateUI()

	if autoWaveSkipEnabled then
		local ws = tryGetWaveSkipGui()
		if ws and ws.Visible then
			handleWaveSkipVisible(updateUI)
		end
	end
end))

maid:Give(tpNpcBtn.MouseButton1Click:Connect(function()
	panelStatus.Text = "Status: Looking for Sung6S..."
	local leftLeg = getSungLeftLegPart()
	if leftLeg then
		teleportToPart(leftLeg)
		panelStatus.Text = "Status: Teleported to Sung6S"
	else
		panelStatus.Text = "Status: Sung6S not loaded yet"
	end
end))

maid:Give(challengeBtn.MouseButton1Click:Connect(function()
	challengeEnabled = not challengeEnabled
	updateChallengeText()

	if challengeEnabled then
		panelStatus.Text = "Status: Challenge enabled (TP Sung -> scan)"
		tpToSungOnEnableDone = false
		lastTeleportTime = 0
		lastStartPressTime = 0
	else
		panelStatus.Text = "Status: Ready"
	end
end))

maid:Give(autoStartBtn.MouseButton1Click:Connect(function()
	autoStartEnabled = not autoStartEnabled
	updateAutoStartText()
	panelStatus.Text = autoStartEnabled and "Status: Auto-start enabled" or "Status: Auto-start disabled"
	lastStartPressTime = 0
end))

maid:Give(startBtn.MouseButton1Click:Connect(function()
	if requestChallengeStart() then
		panelStatus.Text = "Status: Start requested (manual)"
	else
		panelStatus.Text = "Status: Doors remote not found!"
	end
end))

maid:Give(leaveBtn.MouseButton1Click:Connect(function()
	if requestChallengeLeave() then
		panelStatus.Text = "Status: Leave requested"
	else
		panelStatus.Text = "Status: Doors remote not found!"
	end
end))

maid:Give(UpboardRemote.OnClientEvent:Connect(function(action, ...)
	if not stillCurrent() then return end
	if action == "EndGame" then
		handleEndGame(updateUI, setPlayAgainVisibleLabel)
	elseif action == "TurnOffBoard" then
		handleTurnOffBoard(updateUI)
	end
end))

-- ===== START LOOPS =====
startUpboardLoop(updateUI, setPlayAgainVisibleLabel)
hookWaveSkip(updateUI, setWaveSkipVisibleLabel)

updateUI()
processUpgrades(updateUI)

-- Challenge loop (already ON)
task.spawn(function()
	while stillCurrent() do
		task.wait(CHECK_INTERVAL)
		if not challengeEnabled then
			continue
		end

		if not tpToSungOnEnableDone then
			local leftLeg = getSungLeftLegPart()
			if leftLeg then
				panelStatus.Text = "Status: TP Sung6S -> now scanning..."
				teleportToPart(leftLeg)
				tpToSungOnEnableDone = true
			else
				panelStatus.Text = "Status: Waiting for Sung6S..."
				continue
			end
		end

		local targetPart, foundName = findBestMatchDisplayPart()
		if not targetPart then
			panelStatus.Text = "Status: Waiting for Challenge area..."
			continue
		end

		local now = os.clock()
		local dist = distanceFromPlayerTo(targetPart)

		local cooldownOk = (now - lastTeleportTime) >= TELEPORT_COOLDOWN
		local rearmOk = (targetPart ~= lastTargetPart) or (dist >= RETRIGGER_DISTANCE)

		if cooldownOk and rearmOk then
			lastTargetPart = targetPart
			lastTeleportTime = now
			panelStatus.Text = ("Status: %s found! Teleporting..."):format(foundName)
			teleportToPart(targetPart)
			dist = distanceFromPlayerTo(targetPart)
		end

		if autoStartEnabled and dist <= PRESS_START_DISTANCE then
			if (now - lastStartPressTime) >= START_PRESS_COOLDOWN then
				lastStartPressTime = now
				if requestChallengeStart() then
					panelStatus.Text = ("Status: Auto-Start (%s @ %.0f studs)"):format(foundName, dist)
				else
					panelStatus.Text = "Status: Doors remote not found!"
				end
			end
		else
			panelStatus.Text = ("Status: %s (%.0f studs)"):format(foundName, dist)
		end
	end
end)

-- initial status
panelStatus.Text = "Status: Challenge ON (TP Sung -> scan)"
