-- VIP MERGED: Multi Auto + Challenge TP Panel (Singleton + Anti-Crash Auto-Rejoin)
-- Put this LocalScript in StarterPlayerScripts

-- ===== SINGLETON GUARD =====
do
	_G.__VIP_MULTI_AUTO_RUNNING = _G.__VIP_MULTI_AUTO_RUNNING or { running = false, token = 0 }
	if _G.__VIP_MULTI_AUTO_RUNNING.running then
		warn("[VIP] Already running, blocked duplicate.")
		return
	end
	_G.__VIP_MULTI_AUTO_RUNNING.running = true
	_G.__VIP_MULTI_AUTO_RUNNING.token += 1
end

local RUN_TOKEN = _G.__VIP_MULTI_AUTO_RUNNING.token
local function stillCurrent()
	return _G.__VIP_MULTI_AUTO_RUNNING
		and _G.__VIP_MULTI_AUTO_RUNNING.running == true
		and _G.__VIP_MULTI_AUTO_RUNNING.token == RUN_TOKEN
end

-- ===== SERVICES =====
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")
local Stats = game:GetService("Stats")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- remove old guis from previous runs
pcall(function()
	local old = playerGui:FindFirstChild("VIP_MultiAutoGui")
	if old then old:Destroy() end
end)
pcall(function()
	local old = playerGui:FindFirstChild("VIPPanelGui")
	if old then old:Destroy() end
end)

-- ===== REMOTES =====
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local MoneyRemote = Remotes:WaitForChild("Money")
local ChampionRemote = Remotes:WaitForChild("Champion")
local UpboardRemote = Remotes:WaitForChild("Upboard")
local TilePlacementRemote = Remotes:WaitForChild("TilePlacement")

-- ===== CONFIG (MultiAuto) =====
local thresholds = {975, 1150, 1725, 2010, 2530, 2750}

local PRESET_ATTRIBUTE_KEY = "Champion"
local PRESET_ATTRIBUTE_VALUE = "Blade Master"

local UPBOARD_COOLDOWN = 0.75
local UPBOARD_LOOP_INTERVAL = 0.9
local ENDGAME_DELAY = 10 -- waits 10 seconds before PlayAgain/Leave

-- After 15 minutes from script start, ALWAYS leave/return lobby on endgame
local FORCE_LEAVE_AFTER_SECONDS = 15 * 60

-- WaveSkip -> Place -> Vote
local PLACE_ACTION = "Place"
local PLACE_SLOT = "Slot_04"
local PLACE_NAME = "Blade Master"
local PLACE_CFRAME = CFrame.new(
	3838.8388671875, 256.97607421875, -3677.232177734375,
	0, 0, 1,
	0, 1, 0,
	-1, 0, 0
)
local PLACE_TILE = Workspace:WaitForChild("Arena"):WaitForChild("PlacementTile_1_3")
local PLACE_ZERO = 0
local AFTER_PLACE_WAIT = 0.35
local MAX_PLACE_TRIES_THIS_WAVESKIP = 3

-- Auto-Rejoin (Anti-crash)
local autoRejoinEnabled = true
local REJOIN_AT_MB = 4800
local REJOIN_CONFIRM_SECONDS = 8
local REJOIN_COOLDOWN_SECONDS = 120

-- ===== CONFIG (Challenge TP Panel) =====
local CHECK_INTERVAL = 0.25
local TELEPORT_OFFSET_Y = 5

-- TP priority (highest -> lowest)
local TARGET_PRIORITY = {
	"C_A_A_Power Fragment",
	"C_A_A_Deluxe Dice",
	"C_A_C_Dice",
	"C_C_C_Gratifying Soul",
}

local RETRIGGER_DISTANCE = 35
local TELEPORT_COOLDOWN = 2.0

local PRESS_START_DISTANCE = 25
local START_PRESS_COOLDOWN = 0.35

local NPC_FOLDER_PATH = { "NPCs", "Sung6S" }
local R6_LEG = "Left Leg"
local R15_LEG_CANDIDATES = { "LeftLowerLeg", "LeftUpperLeg" }

local HOURLY_IDS = { "Hourly_01_01", "Hourly_02_01", "Hourly_03_01" }

local LOBBY_FOLDER_NAME = "Lobby Relatives"
local DOORS_REMOTE_NAME = "Doors"
local START_A, START_B = "Play", "Challenge"
local LEAVE_A, LEAVE_B = "Leave", "Challenge"

-- ===== HELPERS =====
local function norm(v)
	return tostring(v or ""):lower():gsub("%s+", "")
end
local wantValNorm = norm(PRESET_ATTRIBUTE_VALUE)

local function safeFindChild(root, name)
	if not root then return nil end
	return root:FindFirstChild(name)
end

local function setTextIfChanged(label, txt)
	if label and label.Text ~= txt then
		label.Text = txt
	end
end

local function getClientMemoryMB()
	return Stats:GetTotalMemoryUsageMb()
end

local function getChar()
	return player.Character or player.CharacterAdded:Wait()
end

local function getHRP()
	local char = getChar()
	return char:FindFirstChild("HumanoidRootPart")
end

local function teleportToPart(part)
	local hrp = getHRP()
	if hrp and part and part:IsA("BasePart") then
		hrp.CFrame = part.CFrame * CFrame.new(0, TELEPORT_OFFSET_Y, 0)
	end
end

local function findAncestorByName(inst, name)
	local cur = inst
	while cur do
		if cur.Name == name then return cur end
		cur = cur.Parent
	end
	return nil
end

local function distanceFromPlayerTo(part)
	local hrp = getHRP()
	if not hrp or not part then return math.huge end
	return (hrp.Position - part.Position).Magnitude
end

local function getSungLeftLegPart()
	local cur = workspace
	for _, name in ipairs(NPC_FOLDER_PATH) do
		cur = cur:FindFirstChild(name)
		if not cur then return nil end
	end

	local leg = cur:FindFirstChild(R6_LEG)
	if leg and leg:IsA("BasePart") then
		return leg
	end

	for _, cand in ipairs(R15_LEG_CANDIDATES) do
		local p = cur:FindFirstChild(cand)
		if p and p:IsA("BasePart") then
			return p
		end
	end

	return nil
end

-- ===== MAID =====
local Maid = {}
Maid.__index = Maid
function Maid.new()
	return setmetatable({ tasks = {} }, Maid)
end
function Maid:Give(t)
	table.insert(self.tasks, t)
	return t
end
function Maid:DoCleaning()
	for i = #self.tasks, 1, -1 do
		local t = self.tasks[i]
		self.tasks[i] = nil
		if typeof(t) == "RBXScriptConnection" then
			pcall(function() t:Disconnect() end)
		elseif typeof(t) == "Instance" then
			pcall(function() t:Destroy() end)
		elseif type(t) == "function" then
			pcall(t)
		end
	end
end

local maid = Maid.new()

local function stopAll()
	if not stillCurrent() then return end
	_G.__VIP_MULTI_AUTO_RUNNING.running = false
	maid:DoCleaning()
end

-- ===== 15 MINUTE FORCE-LEAVE TIMER =====
local scriptStartAt = os.clock()
local forceLeaveToLobby = false

task.spawn(function()
	while stillCurrent() do
		if not forceLeaveToLobby and (os.clock() - scriptStartAt) >= FORCE_LEAVE_AFTER_SECONDS then
			forceLeaveToLobby = true
		end
		task.wait(1)
	end
end)

-- ===== PRESET CACHE (Blade Master) =====
local presetsFolder = Workspace:WaitForChild("Presets")
local cachedBladePreset = nil

local function isBladeMasterPreset(preset)
	local attr = preset:GetAttribute(PRESET_ATTRIBUTE_KEY)
	return attr ~= nil and norm(attr) == wantValNorm
end

local function rebuildBladeCache()
	cachedBladePreset = nil
	for _, child in ipairs(presetsFolder:GetChildren()) do
		if isBladeMasterPreset(child) then
			cachedBladePreset = child
			return
		end
	end
end

rebuildBladeCache()

maid:Give(presetsFolder.ChildAdded:Connect(function(child)
	if not stillCurrent() then return end
	if not cachedBladePreset and isBladeMasterPreset(child) then
		cachedBladePreset = child
	end
end))

maid:Give(presetsFolder.ChildRemoved:Connect(function(child)
	if not stillCurrent() then return end
	if child == cachedBladePreset then
		rebuildBladeCache()
	end
end))

local function getBladePreset()
	if cachedBladePreset and cachedBladePreset.Parent == presetsFolder then
		return cachedBladePreset
	end
	rebuildBladeCache()
	return cachedBladePreset
end

-- ===== FEATURE 1: AUTO UPGRADE =====
local autoUpgradeEnabled = false
local currentMoney = 0
local nextIndex = 1
local upgradeBusy = false

local function resetUpgrades(statusFn)
	nextIndex = 1
	upgradeBusy = false
	if statusFn then statusFn("Upgrade: Reset") end
end

local function fireUpgradePreset()
	local preset = getBladePreset()
	if not preset then
		return false, "Upgrade: Preset not found"
	end
	ChampionRemote:FireServer("Upgrade", preset)
	return true, "Upgrade: Sent Upgrade"
end

local function processUpgrades(updateUIFn)
	if not autoUpgradeEnabled then return end
	if upgradeBusy then return end
	if nextIndex > #thresholds then return end

	upgradeBusy = true
	while autoUpgradeEnabled
		and nextIndex <= #thresholds
		and (currentMoney + 1e-6) >= thresholds[nextIndex]
	do
		local target = thresholds[nextIndex]
		if updateUIFn then updateUIFn(("Upgrade: Upgrading @ %d..."):format(target)) end

		local ok, msg = fireUpgradePreset()
		if not ok then
			if updateUIFn then updateUIFn(msg) end
			break
		end

		nextIndex += 1
		task.wait(0.25)
	end
	upgradeBusy = false
end

-- ===== FEATURE 2: AUTO UPBOARD (PlayAgain/Leave) =====
local autoUpboardEnabled = false
local upboardLastAction = nil
local upboardLastFireAt = 0

local function tryGetPlayAgainHolder()
	local upboard = playerGui:FindFirstChild("Upboard")
	if not upboard then return nil end
	local result = safeFindChild(upboard, "Result")
	local main = safeFindChild(result, "Main")
	local options = safeFindChild(main, "Options")
	return safeFindChild(options, "PlayAgainButtonHolder")
end

local function desiredUpboardAction(holder)
	if forceLeaveToLobby then
		return "Leave"
	end
	if not holder then return nil end
	return holder.Visible and "PlayAgain" or "Leave"
end

local function fireUpboardAction(action, updateUIFn, force)
	if not action then return end

	local now = os.clock()
	if not force then
		if now - upboardLastFireAt < UPBOARD_COOLDOWN then return end
		if action == upboardLastAction then return end
	end

	upboardLastAction = action
	upboardLastFireAt = now
	UpboardRemote:FireServer(action)

	if updateUIFn then updateUIFn(("Upboard: Sent %s"):format(action)) end
end

local function startUpboardLoop(updateUIFn, setPlayAgainVisibleLabelFn)
	task.spawn(function()
		while stillCurrent() do
			if autoUpboardEnabled then
				local holder = tryGetPlayAgainHolder()
				if setPlayAgainVisibleLabelFn then
					setPlayAgainVisibleLabelFn(holder and holder.Visible or nil)
				end
				local action = desiredUpboardAction(holder)
				fireUpboardAction(action, updateUIFn, false)
			end
			task.wait(UPBOARD_LOOP_INTERVAL)
		end
	end)
end

-- ===== EndGame handling =====
local endGameTaskId = 0
local function handleEndGame(updateUIFn, setPlayAgainVisibleLabelFn)
	endGameTaskId += 1
	local myId = endGameTaskId

	-- KEEP auto-upgrade as-is, but reset back to first upgrade
	resetUpgrades(updateUIFn)
	if updateUIFn then updateUIFn("Upgrade: Reset (EndGame)") end
	if updateUIFn then updateUIFn() end

	task.delay(ENDGAME_DELAY, function()
		if not stillCurrent() then return end
		if myId ~= endGameTaskId then return end

		local holder = tryGetPlayAgainHolder()
		if setPlayAgainVisibleLabelFn then
			setPlayAgainVisibleLabelFn(holder and holder.Visible or nil)
		end

		local tries = 0
		while stillCurrent() and (not holder) and tries < 20 do
			task.wait(0.25)
			holder = tryGetPlayAgainHolder()
			tries += 1
			if setPlayAgainVisibleLabelFn then
				setPlayAgainVisibleLabelFn(holder and holder.Visible or nil)
			end
		end

		local action
		if forceLeaveToLobby then
			action = "Leave"
		else
			action = (holder and holder.Visible) and "PlayAgain" or "Leave"
		end

		upboardLastAction = nil
		upboardLastFireAt = 0
		fireUpboardAction(action, updateUIFn, true)
	end)
end

local function handleTurnOffBoard(updateUIFn)
	resetUpgrades(updateUIFn)
end

-- ===== FEATURE 3: WAVESKIP -> PLACE -> VOTE =====
local autoWaveSkipEnabled = false
local handlingWaveSkip = false
local waveConn = nil
local waveHookToken = 0

local function tryGetWaveSkipGui()
	local upboard = playerGui:FindFirstChild("Upboard")
	if not upboard then return nil end
	return upboard:FindFirstChild("WaveSkip")
end

local function placeBladeMaster()
	TilePlacementRemote:FireServer(
		PLACE_ACTION, PLACE_SLOT, PLACE_NAME, PLACE_CFRAME, PLACE_TILE, PLACE_ZERO
	)
end

local function handleWaveSkipVisible(updateUIFn)
	if handlingWaveSkip then return end
	handlingWaveSkip = true

	if updateUIFn then updateUIFn("WaveSkip: Visible -> checking Blade Master...") end

	local preset = getBladePreset()
	if preset then
		if updateUIFn then updateUIFn(("WaveSkip: Found (%s) -> Vote"):format(preset.Name)) end
		UpboardRemote:FireServer("Vote")
		handlingWaveSkip = false
		return
	end

	if updateUIFn then updateUIFn("WaveSkip: Not found -> placing Slot_04...") end

	for attempt = 1, MAX_PLACE_TRIES_THIS_WAVESKIP do
		placeBladeMaster()
		if updateUIFn then updateUIFn(("WaveSkip: Placed %d/%d -> wait"):format(attempt, MAX_PLACE_TRIES_THIS_WAVESKIP)) end
		task.wait(AFTER_PLACE_WAIT)

		preset = getBladePreset()
		if preset then
			if updateUIFn then updateUIFn(("WaveSkip: Now found (%s) -> Vote"):format(preset.Name)) end
			UpboardRemote:FireServer("Vote")
			handlingWaveSkip = false
			return
		end
	end

	if updateUIFn then updateUIFn("WaveSkip: Still not found -> Vote anyway") end
	UpboardRemote:FireServer("Vote")
	handlingWaveSkip = false
end

local function unhookWaveSkip()
	if waveConn then
		waveConn:Disconnect()
		waveConn = nil
	end
end

local function hookWaveSkip(updateUIFn, setWaveSkipVisibleLabelFn)
	waveHookToken += 1
	local myToken = waveHookToken

	task.spawn(function()
		while stillCurrent() and myToken == waveHookToken do
			local waveSkip = tryGetWaveSkipGui()
			if waveSkip then
				unhookWaveSkip()

				if setWaveSkipVisibleLabelFn then
					setWaveSkipVisibleLabelFn(waveSkip.Visible)
				end

				local last = waveSkip.Visible

				waveConn = waveSkip:GetPropertyChangedSignal("Visible"):Connect(function()
					if not stillCurrent() then return end
					if myToken ~= waveHookToken then return end

					if setWaveSkipVisibleLabelFn then
						setWaveSkipVisibleLabelFn(waveSkip.Visible)
					end

					if autoWaveSkipEnabled and (not last) and waveSkip.Visible then
						handleWaveSkipVisible(updateUIFn)
					end
					last = waveSkip.Visible
				end)

				maid:Give(waveConn)

				if autoWaveSkipEnabled and waveSkip.Visible then
					handleWaveSkipVisible(updateUIFn)
				end

				while stillCurrent() and myToken == waveHookToken and waveSkip.Parent do
					task.wait(0.6)
				end
			else
				if setWaveSkipVisibleLabelFn then
					setWaveSkipVisibleLabelFn(nil)
				end
				task.wait(0.6)
			end
		end
	end)
end

-- ====== CHALLENGE SCAN HELPERS ======
local function tryGetHolderForHourly(hourlyId)
	local doors = workspace:FindFirstChild("Doors")
	if not doors then return nil end

	local challenge = doors:FindFirstChild("Challenge")
	if not challenge then return nil end

	local hourly = challenge:FindFirstChild(hourlyId)
	if not hourly then return nil end

	local matchDisplayPart = hourly:FindFirstChild("MatchDisplayPart")
	if not matchDisplayPart then return nil end

	local surfaceGui = matchDisplayPart:FindFirstChild("SurfaceGui")
	if not surfaceGui then return nil end

	local frame = surfaceGui:FindFirstChild("MatchDisplayFrame")
	if not frame then return nil end

	local rewards = frame:FindFirstChild("ChallengeRewards")
	if not rewards then return nil end

	return rewards:FindFirstChild("Holder")
end

local function findBestMatchDisplayPart()
	for _, targetName in ipairs(TARGET_PRIORITY) do
		for _, hourlyId in ipairs(HOURLY_IDS) do
			local holder = tryGetHolderForHourly(hourlyId)
			if holder then
				local found = holder:FindFirstChild(targetName, true)
				if found then
					local matchDisplayPart = findAncestorByName(holder, "MatchDisplayPart")
					if matchDisplayPart and matchDisplayPart:IsA("BasePart") then
						return matchDisplayPart, targetName
					end
				end
			end
		end
	end
	return nil
end

-- ====== DOORS REMOTE (Lobby Relatives -> Doors) ======
local function getDoorsRemote()
	local lobby = ReplicatedStorage:FindFirstChild(LOBBY_FOLDER_NAME)
	local r = lobby and lobby:FindFirstChild(DOORS_REMOTE_NAME) or nil
	if r and r:IsA("RemoteEvent") then return r end
	return nil
end

local function requestChallengeStart(statusLabel)
	local doors = getDoorsRemote()
	if not doors then
		if statusLabel then statusLabel.Text = "Status: Doors remote not found!" end
		return false
	end
	doors:FireServer(START_A, START_B)
	return true
end

local function requestChallengeLeave(statusLabel)
	local doors = getDoorsRemote()
	if not doors then
		if statusLabel then statusLabel.Text = "Status: Doors remote not found!" end
		return false
	end
	doors:FireServer(LEAVE_A, LEAVE_B)
	return true
end

-- =======================
-- GUI 1: VIP MultiAuto GUI
-- =======================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "VIP_MultiAutoGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui
maid:Give(screenGui)

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 380, 0, 365)
frame.Position = UDim2.new(0, 20, 0.5, -182)
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 28)
frame.BorderSizePixel = 0
frame.Parent = screenGui
maid:Give(frame)

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = frame
maid:Give(corner)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -60, 0, 24)
title.Position = UDim2.new(0, 10, 0, 8)
title.BackgroundTransparency = 1
title.Text = "VIP Auto Panel"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = frame
maid:Give(title)

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 28, 0, 24)
closeBtn.Position = UDim2.new(1, -38, 0, 8)
closeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
closeBtn.BorderSizePixel = 0
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 14
closeBtn.Parent = frame
maid:Give(closeBtn)

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 8)
closeCorner.Parent = closeBtn
maid:Give(closeCorner)

local upgradeStatus = Instance.new("TextLabel")
upgradeStatus.Size = UDim2.new(1, -20, 0, 18)
upgradeStatus.Position = UDim2.new(0, 10, 0, 38)
upgradeStatus.BackgroundTransparency = 1
upgradeStatus.Text = "Upgrade: OFF"
upgradeStatus.TextColor3 = Color3.fromRGB(200, 200, 200)
upgradeStatus.Font = Enum.Font.Gotham
upgradeStatus.TextSize = 13
upgradeStatus.TextXAlignment = Enum.TextXAlignment.Left
upgradeStatus.Parent = frame
maid:Give(upgradeStatus)

local moneyLabel = Instance.new("TextLabel")
moneyLabel.Size = UDim2.new(1, -20, 0, 18)
moneyLabel.Position = UDim2.new(0, 10, 0, 58)
moneyLabel.BackgroundTransparency = 1
moneyLabel.Text = "Money: 0"
moneyLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
moneyLabel.Font = Enum.Font.Gotham
moneyLabel.TextSize = 13
moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
moneyLabel.Parent = frame
maid:Give(moneyLabel)

local nextLabel = Instance.new("TextLabel")
nextLabel.Size = UDim2.new(1, -20, 0, 18)
nextLabel.Position = UDim2.new(0, 10, 0, 78)
nextLabel.BackgroundTransparency = 1
nextLabel.Text = "Next: 975"
nextLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
nextLabel.Font = Enum.Font.Gotham
nextLabel.TextSize = 13
nextLabel.TextXAlignment = Enum.TextXAlignment.Left
nextLabel.Parent = frame
maid:Give(nextLabel)

local presetLabel = Instance.new("TextLabel")
presetLabel.Size = UDim2.new(1, -20, 0, 18)
presetLabel.Position = UDim2.new(0, 10, 0, 98)
presetLabel.BackgroundTransparency = 1
presetLabel.Text = "Preset: (searching...)"
presetLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
presetLabel.Font = Enum.Font.Gotham
presetLabel.TextSize = 12
presetLabel.TextXAlignment = Enum.TextXAlignment.Left
presetLabel.Parent = frame
maid:Give(presetLabel)

local upboardStatus = Instance.new("TextLabel")
upboardStatus.Size = UDim2.new(1, -20, 0, 18)
upboardStatus.Position = UDim2.new(0, 10, 0, 128)
upboardStatus.BackgroundTransparency = 1
upboardStatus.Text = "Upboard: OFF"
upboardStatus.TextColor3 = Color3.fromRGB(200, 200, 200)
upboardStatus.Font = Enum.Font.Gotham
upboardStatus.TextSize = 13
upboardStatus.TextXAlignment = Enum.TextXAlignment.Left
upboardStatus.Parent = frame
maid:Give(upboardStatus)

local playAgainVisibleLabel = Instance.new("TextLabel")
playAgainVisibleLabel.Size = UDim2.new(1, -20, 0, 18)
playAgainVisibleLabel.Position = UDim2.new(0, 10, 0, 148)
playAgainVisibleLabel.BackgroundTransparency = 1
playAgainVisibleLabel.Text = "PlayAgainHolder.Visible: (waiting...)"
playAgainVisibleLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
playAgainVisibleLabel.Font = Enum.Font.Gotham
playAgainVisibleLabel.TextSize = 12
playAgainVisibleLabel.TextXAlignment = Enum.TextXAlignment.Left
playAgainVisibleLabel.Parent = frame
maid:Give(playAgainVisibleLabel)

local waveSkipStatus = Instance.new("TextLabel")
waveSkipStatus.Size = UDim2.new(1, -20, 0, 18)
waveSkipStatus.Position = UDim2.new(0, 10, 0, 178)
waveSkipStatus.BackgroundTransparency = 1
waveSkipStatus.Text = "WaveSkip: OFF"
waveSkipStatus.TextColor3 = Color3.fromRGB(200, 200, 200)
waveSkipStatus.Font = Enum.Font.Gotham
waveSkipStatus.TextSize = 13
waveSkipStatus.TextXAlignment = Enum.TextXAlignment.Left
waveSkipStatus.Parent = frame
maid:Give(waveSkipStatus)

local waveSkipVisibleLabel = Instance.new("TextLabel")
waveSkipVisibleLabel.Size = UDim2.new(1, -20, 0, 18)
waveSkipVisibleLabel.Position = UDim2.new(0, 10, 0, 198)
waveSkipVisibleLabel.BackgroundTransparency = 1
waveSkipVisibleLabel.Text = "WaveSkip.Visible: (waiting...)"
waveSkipVisibleLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
waveSkipVisibleLabel.Font = Enum.Font.Gotham
waveSkipVisibleLabel.TextSize = 12
waveSkipVisibleLabel.TextXAlignment = Enum.TextXAlignment.Left
waveSkipVisibleLabel.Parent = frame
maid:Give(waveSkipVisibleLabel)

local memoryLabel = Instance.new("TextLabel")
memoryLabel.Size = UDim2.new(1, -20, 0, 18)
memoryLabel.Position = UDim2.new(0, 10, 0, 228)
memoryLabel.BackgroundTransparency = 1
memoryLabel.Text = "Memory: ..."
memoryLabel.TextColor3 = Color3.fromRGB(160, 160, 160)
memoryLabel.Font = Enum.Font.Gotham
memoryLabel.TextSize = 12
memoryLabel.TextXAlignment = Enum.TextXAlignment.Left
memoryLabel.Parent = frame
maid:Give(memoryLabel)

local upgradeToggle = Instance.new("TextButton")
upgradeToggle.Size = UDim2.new(0.33, -14, 0, 34)
upgradeToggle.Position = UDim2.new(0, 10, 1, -44)
upgradeToggle.BackgroundColor3 = Color3.fromRGB(70, 70, 75)
upgradeToggle.BorderSizePixel = 0
upgradeToggle.Text = "Upgrade: OFF"
upgradeToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
upgradeToggle.Font = Enum.Font.GothamBold
upgradeToggle.TextSize = 14
upgradeToggle.Parent = frame
maid:Give(upgradeToggle)

local upboardToggle = Instance.new("TextButton")
upboardToggle.Size = UDim2.new(0.33, -14, 0, 34)
upboardToggle.Position = UDim2.new(0.33, 7, 1, -44)
upboardToggle.BackgroundColor3 = Color3.fromRGB(70, 70, 75)
upboardToggle.BorderSizePixel = 0
upboardToggle.Text = "Upboard: OFF"
upboardToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
upboardToggle.Font = Enum.Font.GothamBold
upboardToggle.TextSize = 14
upboardToggle.Parent = frame
maid:Give(upboardToggle)

local waveSkipToggle = Instance.new("TextButton")
waveSkipToggle.Size = UDim2.new(0.34, -14, 0, 34)
waveSkipToggle.Position = UDim2.new(0.66, 7, 1, -44)
waveSkipToggle.BackgroundColor3 = Color3.fromRGB(70, 70, 75)
waveSkipToggle.BorderSizePixel = 0
waveSkipToggle.Text = "WaveSkip: OFF"
waveSkipToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
waveSkipToggle.Font = Enum.Font.GothamBold
waveSkipToggle.TextSize = 14
waveSkipToggle.Parent = frame
maid:Give(waveSkipToggle)

local c1 = Instance.new("UICorner"); c1.CornerRadius = UDim.new(0, 10); c1.Parent = upgradeToggle; maid:Give(c1)
local c2 = Instance.new("UICorner"); c2.CornerRadius = UDim.new(0, 10); c2.Parent = upboardToggle; maid:Give(c2)
local c3 = Instance.new("UICorner"); c3.CornerRadius = UDim.new(0, 10); c3.Parent = waveSkipToggle; maid:Give(c3)

local rejoinToggle = Instance.new("TextButton")
rejoinToggle.Size = UDim2.new(1, -20, 0, 30)
rejoinToggle.Position = UDim2.new(0, 10, 0, 252)
rejoinToggle.BackgroundColor3 = Color3.fromRGB(0, 170, 85)
rejoinToggle.BorderSizePixel = 0
rejoinToggle.Text = "Auto-Rejoin: ON"
rejoinToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
rejoinToggle.Font = Enum.Font.GothamBold
rejoinToggle.TextSize = 13
rejoinToggle.Parent = frame
maid:Give(rejoinToggle)

local rC = Instance.new("UICorner"); rC.CornerRadius = UDim.new(0, 10); rC.Parent = rejoinToggle; maid:Give(rC)

local function setPlayAgainVisibleLabel(v)
	if v == nil then
		setTextIfChanged(playAgainVisibleLabel, "PlayAgainHolder.Visible: (waiting...)")
	else
		setTextIfChanged(playAgainVisibleLabel, "PlayAgainHolder.Visible: " .. tostring(v))
	end
end

local function setWaveSkipVisibleLabel(v)
	if v == nil then
		setTextIfChanged(waveSkipVisibleLabel, "WaveSkip.Visible: (waiting...)")
	else
		setTextIfChanged(waveSkipVisibleLabel, "WaveSkip.Visible: " .. tostring(v))
	end
end

local function updateUI(statusText)
	setTextIfChanged(moneyLabel, ("Money: %d"):format(math.floor(currentMoney + 0.5)))
	local nextTarget = thresholds[nextIndex]
	setTextIfChanged(nextLabel, nextTarget and ("Next: %d"):format(nextTarget) or "Next: DONE")

	local preset = getBladePreset()
	setTextIfChanged(presetLabel, ("Preset: %s"):format(preset and preset.Name or "(not found)"))

	upgradeToggle.Text = autoUpgradeEnabled and "Upgrade: ON" or "Upgrade: OFF"
	upgradeToggle.BackgroundColor3 = autoUpgradeEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)

	upboardToggle.Text = autoUpboardEnabled and "Upboard: ON" or "Upboard: OFF"
	upboardToggle.BackgroundColor3 = autoUpboardEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)

	waveSkipToggle.Text = autoWaveSkipEnabled and "WaveSkip: ON" or "WaveSkip: OFF"
	waveSkipToggle.BackgroundColor3 = autoWaveSkipEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)

	rejoinToggle.Text = autoRejoinEnabled and "Auto-Rejoin: ON" or "Auto-Rejoin: OFF"
	rejoinToggle.BackgroundColor3 = autoRejoinEnabled and Color3.fromRGB(0, 170, 85) or Color3.fromRGB(70, 70, 75)

	if statusText then
		if statusText:sub(1, 7) == "Upgrade" then
			setTextIfChanged(upgradeStatus, statusText)
		elseif statusText:sub(1, 6) == "Upboard" then
			setTextIfChanged(upboardStatus, statusText)
		elseif statusText:sub(1, 7) == "WaveSkip" then
			setTextIfChanged(waveSkipStatus, statusText)
		end
	else
		setTextIfChanged(upgradeStatus, autoUpgradeEnabled and "Upgrade: ON" or "Upgrade: OFF")
		setTextIfChanged(upboardStatus, autoUpboardEnabled and "Upboard: ON" or "Upboard: OFF")
		setTextIfChanged(waveSkipStatus, autoWaveSkipEnabled and "WaveSkip: ON" or "WaveSkip: OFF")
	end
end

-- =======================
-- GUI 2: Challenge TP Panel (Draggable)
-- =======================
local panelGui = Instance.new("ScreenGui")
panelGui.Name = "VIPPanelGui"
panelGui.ResetOnSpawn = false
panelGui.Parent = playerGui
maid:Give(panelGui)

local panelFrame = Instance.new("Frame")
panelFrame.Name = "MainFrame"
panelFrame.Size = UDim2.new(0, 280, 0, 305)
panelFrame.Position = UDim2.new(0.15, 0, 0.35, 0)
panelFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
panelFrame.BorderSizePixel = 0
panelFrame.Parent = panelGui
maid:Give(panelFrame)

local panelCorner = Instance.new("UICorner")
panelCorner.CornerRadius = UDim.new(0, 10)
panelCorner.Parent = panelFrame
maid:Give(panelCorner)

local panelTitle = Instance.new("TextLabel")
panelTitle.Size = UDim2.new(1, -20, 0, 28)
panelTitle.Position = UDim2.new(0, 10, 0, 6)
panelTitle.BackgroundTransparency = 1
panelTitle.Text = "VIP Panel"
panelTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
panelTitle.TextScaled = true
panelTitle.Font = Enum.Font.GothamBold
panelTitle.Parent = panelFrame
maid:Give(panelTitle)

local panelStatus = Instance.new("TextLabel")
panelStatus.Size = UDim2.new(1, -20, 0, 20)
panelStatus.Position = UDim2.new(0, 10, 0, 34)
panelStatus.BackgroundTransparency = 1
panelStatus.Text = "Status: Ready"
panelStatus.TextColor3 = Color3.fromRGB(200, 200, 200)
panelStatus.TextScaled = true
panelStatus.Font = Enum.Font.Gotham
panelStatus.Parent = panelFrame
maid:Give(panelStatus)

local tpNpcBtn = Instance.new("TextButton")
tpNpcBtn.Size = UDim2.new(1, -20, 0, 44)
tpNpcBtn.Position = UDim2.new(0, 10, 0, 60)
tpNpcBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 250)
tpNpcBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
tpNpcBtn.TextScaled = true
tpNpcBtn.Font = Enum.Font.GothamBold
tpNpcBtn.Text = "TP to Sung6S Left Leg"
tpNpcBtn.Parent = panelFrame
maid:Give(tpNpcBtn)

local tpCorner = Instance.new("UICorner")
tpCorner.CornerRadius = UDim.new(0, 8)
tpCorner.Parent = tpNpcBtn
maid:Give(tpCorner)

local challengeBtn = Instance.new("TextButton")
challengeBtn.Size = UDim2.new(1, -20, 0, 44)
challengeBtn.Position = UDim2.new(0, 10, 0, 112)
challengeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
challengeBtn.TextScaled = true
challengeBtn.Font = Enum.Font.GothamBold
challengeBtn.Parent = panelFrame
maid:Give(challengeBtn)

local challengeCorner = Instance.new("UICorner")
challengeCorner.CornerRadius = UDim.new(0, 8)
challengeCorner.Parent = challengeBtn
maid:Give(challengeCorner)

local startBtn = Instance.new("TextButton")
startBtn.Size = UDim2.new(1, -20, 0, 40)
startBtn.Position = UDim2.new(0, 10, 0, 166)
startBtn.BackgroundColor3 = Color3.fromRGB(240, 170, 60)
startBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
startBtn.TextScaled = true
startBtn.Font = Enum.Font.GothamBold
startBtn.Text = "START"
startBtn.Parent = panelFrame
maid:Give(startBtn)

local startCorner = Instance.new("UICorner")
startCorner.CornerRadius = UDim.new(0, 8)
startCorner.Parent = startBtn
maid:Give(startCorner)

local leaveBtn = Instance.new("TextButton")
leaveBtn.Size = UDim2.new(1, -20, 0, 40)
leaveBtn.Position = UDim2.new(0, 10, 0, 212)
leaveBtn.BackgroundColor3 = Color3.fromRGB(220, 70, 70)
leaveBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
leaveBtn.TextScaled = true
leaveBtn.Font = Enum.Font.GothamBold
leaveBtn.Text = "LEAVE"
leaveBtn.Parent = panelFrame
maid:Give(leaveBtn)

local leaveCorner = Instance.new("UICorner")
leaveCorner.CornerRadius = UDim.new(0, 8)
leaveCorner.Parent = leaveBtn
maid:Give(leaveCorner)

local autoStartBtn = Instance.new("TextButton")
autoStartBtn.Size = UDim2.new(1, -20, 0, 40)
autoStartBtn.Position = UDim2.new(0, 10, 0, 258)
autoStartBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
autoStartBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoStartBtn.TextScaled = true
autoStartBtn.Font = Enum.Font.GothamBold
autoStartBtn.Text = "Auto-Start: OFF"
autoStartBtn.Parent = panelFrame
maid:Give(autoStartBtn)

local autoStartCorner = Instance.new("UICorner")
autoStartCorner.CornerRadius = UDim.new(0, 8)
autoStartCorner.Parent = autoStartBtn
maid:Give(autoStartCorner)

-- ===== DRAGGING (Panel) =====
do
	local dragging, dragInput, dragStart, startPos = false, nil, nil, nil
	local function updateDrag(input)
		local delta = input.Position - dragStart
		panelFrame.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end

	maid:Give(panelFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = panelFrame.Position
			local conn
			conn = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					if conn then conn:Disconnect() end
				end
			end)
		end
	end))

	maid:Give(panelFrame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end))

	maid:Give(UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			updateDrag(input)
		end
	end))
end

-- ===== Challenge Panel State =====
local challengeEnabled = false
local autoStartEnabled = false
local lastTargetPart = nil
local lastTeleportTime = 0
local lastStartPressTime = 0

local function updateChallengeText()
	if challengeEnabled then
		challengeBtn.Text = "Challenge Check: ON"
		challengeBtn.BackgroundColor3 = Color3.fromRGB(70, 140, 70)
	else
		challengeBtn.Text = "Challenge Check: OFF"
		challengeBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	end
end

local function updateAutoStartText()
	if autoStartEnabled then
		autoStartBtn.Text = "Auto-Start: ON"
		autoStartBtn.BackgroundColor3 = Color3.fromRGB(70, 140, 70)
	else
		autoStartBtn.Text = "Auto-Start: OFF"
		autoStartBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	end
end

updateChallengeText()
updateAutoStartText()

-- ===== AUTO-REJOIN LOOP =====
local lastOverAt = 0
local lastRejoinAt = 0

task.spawn(function()
	while stillCurrent() do
		local mem = getClientMemoryMB()
		setTextIfChanged(memoryLabel, ("Memory: %d MB"):format(math.floor(mem + 0.5)))

		local now = os.clock()

		if autoRejoinEnabled then
			if mem >= REJOIN_AT_MB then
				if lastOverAt == 0 then lastOverAt = now end

				local overFor = now - lastOverAt
				local sinceLast = now - lastRejoinAt

				if overFor >= REJOIN_CONFIRM_SECONDS and sinceLast >= REJOIN_COOLDOWN_SECONDS then
					lastRejoinAt = now
					lastOverAt = 0

					pcall(function() stopAll() end)
					pcall(function()
						TeleportService:Teleport(game.PlaceId, player)
					end)
					return
				end
			else
				lastOverAt = 0
			end
		else
			lastOverAt = 0
		end

		task.wait(1)
	end
end)

-- ===== BUTTON EVENTS (MultiAuto) =====
maid:Give(closeBtn.MouseButton1Click:Connect(function()
	stopAll()
end))

maid:Give(rejoinToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoRejoinEnabled = not autoRejoinEnabled
	updateUI()
end))

maid:Give(MoneyRemote.OnClientEvent:Connect(function(action, amount)
	if not stillCurrent() then return end
	if action ~= "Update" then return end
	currentMoney = tonumber(amount) or 0
	updateUI()
	processUpgrades(updateUI)
end))

maid:Give(upgradeToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoUpgradeEnabled = not autoUpgradeEnabled
	updateUI()
	processUpgrades(updateUI)
end))

maid:Give(upboardToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoUpboardEnabled = not autoUpboardEnabled
	if autoUpboardEnabled then
		upboardLastAction = nil
		upboardLastFireAt = 0
	end
	updateUI()
end))

maid:Give(waveSkipToggle.MouseButton1Click:Connect(function()
	if not stillCurrent() then return end
	autoWaveSkipEnabled = not autoWaveSkipEnabled
	handlingWaveSkip = false
	updateUI()

	if autoWaveSkipEnabled then
		local ws = tryGetWaveSkipGui()
		if ws and ws.Visible then
			handleWaveSkipVisible(updateUI)
		end
	end
end))

maid:Give(UpboardRemote.OnClientEvent:Connect(function(action, ...)
	if not stillCurrent() then return end
	if action == "EndGame" then
		handleEndGame(updateUI, setPlayAgainVisibleLabel)
	elseif action == "TurnOffBoard" then
		handleTurnOffBoard(updateUI)
	end
end))

-- ===== BUTTON EVENTS (Challenge Panel) =====
maid:Give(tpNpcBtn.MouseButton1Click:Connect(function()
	panelStatus.Text = "Status: Looking for Sung6S..."
	local leftLeg = getSungLeftLegPart()
	if leftLeg then
		teleportToPart(leftLeg)
		panelStatus.Text = "Status: Teleported to Sung6S"
	else
		panelStatus.Text = "Status: Sung6S not loaded yet"
	end
end))

maid:Give(challengeBtn.MouseButton1Click:Connect(function()
	challengeEnabled = not challengeEnabled
	updateChallengeText()
	panelStatus.Text = challengeEnabled and "Status: Challenge check enabled" or "Status: Ready"
	lastTeleportTime = 0
	lastStartPressTime = 0
end))

maid:Give(autoStartBtn.MouseButton1Click:Connect(function()
	autoStartEnabled = not autoStartEnabled
	updateAutoStartText()
	panelStatus.Text = autoStartEnabled and "Status: Auto-start enabled" or "Status: Auto-start disabled"
	lastStartPressTime = 0
end))

maid:Give(startBtn.MouseButton1Click:Connect(function()
	if requestChallengeStart(panelStatus) then
		panelStatus.Text = "Status: Start requested (manual)"
	end
end))

maid:Give(leaveBtn.MouseButton1Click:Connect(function()
	if requestChallengeLeave(panelStatus) then
		panelStatus.Text = "Status: Leave requested"
	end
end))

-- ===== START LOOPS =====
startUpboardLoop(updateUI, setPlayAgainVisibleLabel)
hookWaveSkip(updateUI, setWaveSkipVisibleLabel)
updateUI()

task.spawn(function()
	while stillCurrent() do
		task.wait(CHECK_INTERVAL)

		if not challengeEnabled then
			continue
		end

		local targetPart, foundName = findBestMatchDisplayPart()
		if not targetPart then
			panelStatus.Text = "Status: Waiting for Challenge area..."
			continue
		end

		local now = os.clock()
		local dist = distanceFromPlayerTo(targetPart)

		local cooldownOk = (now - lastTeleportTime) >= TELEPORT_COOLDOWN
		local rearmOk = (targetPart ~= lastTargetPart) or (dist >= RETRIGGER_DISTANCE)

		if cooldownOk and rearmOk then
			lastTargetPart = targetPart
			lastTeleportTime = now
			panelStatus.Text = ("Status: %s found! Teleporting..."):format(foundName)
			teleportToPart(targetPart)
			dist = distanceFromPlayerTo(targetPart)
		end

		if autoStartEnabled and dist <= PRESS_START_DISTANCE then
			if (now - lastStartPressTime) >= START_PRESS_COOLDOWN then
				lastStartPressTime = now
				if requestChallengeStart(panelStatus) then
					panelStatus.Text = ("Status: Auto-Start (%s @ %.0f studs)"):format(foundName, dist)
				end
			end
		else
			panelStatus.Text = ("Status: %s (%.0f studs)"):format(foundName, dist)
		end
	end
end)
